import java.awt.Color;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.ArrayList;
import javax.swing.JOptionPane;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author .foxsake
 */
public class ButtonsPanel extends javax.swing.JPanel implements MouseListener{
    private PathButton[][] buttons = new PathButton[100][100];
    private ArrayList<PathButton> stack = new ArrayList();
    private ArrayList<ArrayList> finished = new ArrayList();
    private ArrayList<ArrayList>shortestList = new ArrayList();
    private PathButton buttonStart;
    private PathButton buttonFinish;
    private PathButton lastPressed;
    private PathButton hovering;
    private int matrixSize;
    /**
     * Creates new form ButtonsPanel
     */
    public ButtonsPanel() {
        matrixSize = 5;
        initComponents();
        for(int i=0;i<matrixSize;i++)
            for(int j=0;j<matrixSize;j++)
                buttons[i][j] = new PathButton(i,j);
        setLayout(new java.awt.GridLayout(matrixSize, matrixSize));
        for(int i=0;i<matrixSize;i++)
            for(int j=0;j<matrixSize;j++)
                this.add(buttons[i][j]);
        for(int i=0;i<matrixSize;i++)
            for(int j=0;j<matrixSize;j++)
                buttons[i][j].addMouseListener(this);
        //default 
        buttonStart=buttons[1][1];
        buttonFinish=buttons[matrixSize-2][matrixSize-2];
        buttonStart.setStart(true);
        buttonFinish.setFinish(true);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBackground(new java.awt.Color(0, 0, 0));
        setLayout(new java.awt.GridLayout(5, 5, 2, 2));
    }// </editor-fold>//GEN-END:initComponents

    public void start(){
        searchWay(buttonStart,buttonStart);
        if(finished.isEmpty()){
                removeOldPath();
                JOptionPane.showMessageDialog(null, "No Possible Path");
        }else{
            removeOldPath();
            shortestList = findShortest();
            selectPaths();
        }
        finished.clear();
    }
    
    private void selectPaths(){
        for(ArrayList<PathButton> gbtns:shortestList){
            int count = 0;
            for(PathButton gbtn : gbtns){
                if(count!=0){
                    gbtn.setBackground(Color.green);
                    gbtn.setText(String.valueOf(count));
                }
                count++;
            }
        }
    }
    
    private void toggle(PathButton gb){
        if(gb.isBlocked()==true){
            gb.setBlocked(false);
        }else{
            gb.setBlocked(true);
        }
        gb.resetText();
    }
    
    public void clear(){
        for(int i=0;i<matrixSize;i++)
            for(int j=0;j<matrixSize;j++){
                buttons[i][j].setBlocked(false);
                if(!buttons[i][j].isStart()&&!buttons[i][j].isFinish())
                    buttons[i][j].resetText();
            }
        stack.clear();
        finished.clear();
        shortestList.clear();
    }
    
    public void removeOldPath(){
        for(int i=0;i<matrixSize;i++)
            for(int j=0;j<matrixSize;j++){
                if(!buttons[i][j].isStart()&&!buttons[i][j].isFinish()&&!buttons[i][j].isBlocked())
                    buttons[i][j].reset();
            }
    }
    
    public void blockAll(){
        for(int i=0;i<matrixSize;i++){
            for(int j=0;j<matrixSize;j++){
                if(!buttons[i][j].isStart()&&!buttons[i][j].isFinish()){
                    buttons[i][j].setBlocked(true);
                    buttons[i][j].resetText();
                }
            }
        }
        if(shortestList!=null)
            shortestList.clear();
    }
    
    public void inverseBlocked(){
        for(int i=0;i<matrixSize;i++){
            for(int j=0;j<matrixSize;j++)
                if(!buttons[i][j].isStart()&&!buttons[i][j].isFinish())
                    toggle(buttons[i][j]);
        }
        if(shortestList!=null)
            shortestList.clear();
    }
    
    private void searchWay(PathButton pathButton,PathButton last){
        int i;
        int j;
        int l;
        int m;
        //left
        if(pathButton.getRow()-1 < 0)
            i=pathButton.getRow();
        else
            i=pathButton.getRow()-1;
        //right
        if(pathButton.getRow()+1 > (matrixSize-1))
            l=pathButton.getRow();
        else
            l=pathButton.getRow()+1;
        //up
        if(pathButton.getCol()-1 < 0)
            j=pathButton.getCol();
        else
            j=pathButton.getCol()-1;
        //down
        if(pathButton.getCol()+1 > (matrixSize-1))
            m = pathButton.getCol();
        else
            m = pathButton.getCol()+1;
        while(i <= l){//row
            int n = j;
            while(n <= m){//column
                if(!buttons[i][n].isBlocked() && !buttons[i][n].isStart() && buttons[i][n]!=last && !lookBack(pathButton) && !goinBack(pathButton)){
                    if((i != pathButton.getRow() || n != pathButton.getCol())){
                        //System.out.println("Row = "+i+" Col = "+n);//debug
                        if(buttons[i][n].isFinish()){
                            stack.add(buttons[pathButton.getRow()][pathButton.getCol()]);
                            finished.add((ArrayList)stack.clone());
                            stack.remove(stack.size()-1);
                            break;
                        }else{
                            stack.add(buttons[pathButton.getRow()][pathButton.getCol()]);
                            searchWay(buttons[i][n],buttons[pathButton.getRow()][pathButton.getCol()]);
                            stack.remove(stack.size()-1);
                        }
                    }
                }
                n++;
            }
            i++;
        }
    }
    
    private boolean goinBack(PathButton pathButton){
        if(stack.size()<3)
            return false;
        int i,j,l,m;
        PathButton gFather = stack.get(stack.size()-2);
        if(pathButton.getRow()-1 < 0)
            i=pathButton.getRow();
        else
            i=pathButton.getRow()-1;
        //right
        if(pathButton.getRow()+1 > (matrixSize-1))
            l=pathButton.getRow();
        else
            l=pathButton.getRow()+1;
        //up
        if(pathButton.getCol()-1 < 0)
            j=pathButton.getCol();
        else
            j=pathButton.getCol()-1;
        //down
        if(pathButton.getCol()+1 > (matrixSize-1))
            m = pathButton.getCol();
        else
            m = pathButton.getCol()+1;
        while(i <= l){//row
            int n = j;
            while(n <= m){//column
                if(!buttons[i][n].isBlocked() && !buttons[i][n].isStart() && !buttons[i][n].isFinish())
                if(buttons[i][n] == gFather){
                    if((i != pathButton.getRow() || n != pathButton.getCol())){
                        return true;
                    }
                }
                n++;
            }
            i++;
        }
        return false;
    }
    
    private boolean lookBack(PathButton pb){
        for(PathButton crossed:stack){
            if(pb==crossed)
                return true;
        }
        return false;
    }
    
    private ArrayList<ArrayList> findShortest(){
        ArrayList<PathButton> shortest;
        ArrayList<ArrayList> shortestList = new ArrayList();
        shortest = finished.get(0);
        for(ArrayList<PathButton> ar : finished){
            if(ar.size()<shortest.size())
                shortest = ar;
        }
        shortestList.add(shortest);
        for(ArrayList<PathButton> ar : finished){
            if(shortest.size()>=ar.size() && ar != shortest){
                shortestList.add(ar);
            }
        }
        return shortestList;
    }
    
    public ArrayList<ArrayList> getShortList(){
        return shortestList;
    }
    
    public PathButton[][] getButtons(){
        return buttons;
    }
    
    public void selectPath(int index){
        if(shortestList!=null&&index>=0){
            selectPaths();
        ArrayList<PathButton> al = shortestList.get(index);
        int count=0;
        for(PathButton pb:al){
            if(count>0)
                pb.setBackground(Color.orange);
            count++;
        }
        }
        if(index==-1&&shortestList!=null)
            selectPaths();
    }
    
    private void moveStart(PathButton pb){
        if(pb!=buttonFinish){
            buttonStart.setStart(false);
            pb.setStart(true);
            buttonStart = pb;
            //clear();
        }
    }
    private void moveFinish(PathButton pb){
        if(pb!=buttonStart){
            buttonFinish.setFinish(false);
            pb.setFinish(true);
            buttonFinish = pb;
            //clear();
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public void mouseClicked(MouseEvent e) {
        if(((PathButton)e.getSource()).isStart()){
            start();
        }else if(((PathButton)e.getSource()).isFinish()){
            clear();
        }else
            toggle((PathButton)e.getSource());
        if(shortestList!=null&&e.getSource()!=buttonStart)
            shortestList.clear();
    }

    @Override
    public void mousePressed(MouseEvent e) {
        lastPressed = (PathButton)e.getSource();
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        if(lastPressed==buttonStart)
            moveStart(hovering);
        else if(lastPressed==buttonFinish)
            moveFinish(hovering);
    }

    @Override
    public void mouseEntered(MouseEvent e) {
        hovering = (PathButton)e.getSource();
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }
}
